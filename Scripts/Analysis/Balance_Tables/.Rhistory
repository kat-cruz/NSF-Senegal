# long_data$y_treatment3 <- ifelse(long_data$group == "Treatment3", 1, 0)
# long_data$y_lc_control <- ifelse(long_data$group == "Local Control", 1, 0)
# long_data$y_control <- ifelse(long_data$group == "Control", 1, 0)
# view(long_data)
# # Run multinomial logistic regression (with control as baseline)
# model_f_test <- multinom(cbind(y_treatment1, y_treatment2, y_treatment3, y_lc_control, y_control) ~ value + variable, data = long_data)
#
# # View model_f_test summary
# summary(model_f_test)
# model_summary <- summary(model_f_test)
# # Perform likelihood ratio tests for the joint null hypothesis
# lr_test <- lrtest(model_f_test)
# lr_test
# summary(lr_test)
# model_summary
# # Extract coefficients and p-values
# #model_summary <- summary(model_f_test)$coefficients
# model_p_values <- model_summary$coefficients[, 4]  # p-values are typically in the 4th column of the coefficients matrix
#
# q_values <- p.adjust(model_p_values, method = "fdr")
#
# # Combine results into a tidy table
# f_test_results <- tibble(
#   variable = rownames(model_summary$coefficients),
#   coef_treatment1 = model_summary$coefficients[, 1],  # Coefficients for Treatment1
#   coef_treatment2 = model_summary$coefficients[, 2],  # Coefficients for Treatment2
#   coef_treatment3 = model_summary$coefficients[, 3],  # Coefficients for Treatment3
#   coef_control = model_summary$coefficients[, 4],     # Coefficients for Control
#   p_values = model_p_values,
#   q_values = q_values
# )
#
# # View regression results
# f_test_results
# Define the file paths
proj_paths <- list(
projects = "C:/Users/Kateri/Box/NSF Senegal",
alternative_projects = "C:/Users/km978/Box/NSF Senegal"
)
# Check if the Kateri path exists and resolve the project path accordingly
if (file.exists(proj_paths$projects)) {
proj <- kwb.utils::resolve(list(
projects = proj_paths$projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
} else {
proj <- kwb.utils::resolve(list(
projects = proj_paths$alternative_projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
}
file_path_balance_tables_df <- file.path(proj$p1, "baseline_balance_tables_data_PAP.dta")
balance_df <- read_dta(file_path_balance_tables_df)
balance_df
trained_hh variable
joint_df <- balance_df %>%
mutate(
group = str_sub(hhid, 3, 4),
treatment_group = case_when(
group %in% c("0A", "0B") ~ "Control",
group %in% c("1A", "1B") ~ "Treatment1",
group %in% c("2A", "2B") ~ "Treatment2",
group %in% c("3A", "3B") ~ "Treatment3",
)
) %>% select(-group)
joint_long_data <- joint_df %>%
pivot_longer(
cols = -c(hhid, hhid_village, treatment_group),  # Keep hhid and group as is, pivot all other columns
names_to = "variable",    # Create a column named "variable" for former column names
values_to = "value"       # Store values in a column named "value"
)
joint_long_data <- joint_long_data %>%
rename(group = treatment_group)
view(joint_long_data)
setwd("C:/Users/km978/Box/NSF Senegal/Data_Management/Output/Data_Analysis/Balance_Tables")
#library(nnet)
model <- multinom(group ~ value, data = joint_long_data)
summary(model)
#View(joint_long_data)
# Create the coefficient names for linearHypothesis
#coefs <- c("valueTreatment1.", "valueTreatment2.", "valueTreatment3.")
# Set up the vector of treatment levels
treatments <- c("Treatment1.", "Treatment2.", "Treatment3.")
# Set up the vector of variables (just "value" here)
variables <- c("value")
# Create the coefficient names using outer to combine treatment levels and variables
coefs <- as.vector(outer(treatments, variables, paste0))
# Print the resulting coefficient names
print(coefs)
# Install and load car package for linearHypothesis
library(car)
# Run the Wald test to check the joint significance of 'value' across the treatments
joint_test <- linearHypothesis(model, coefs)
# Print the results of the joint test
print(joint_test)
#join_f_vars <- setdiff(names(balance_df), c("hhid", "hhid_village", "treatment_group"))
summary(model)
# For Treatment1
joint_test_df <- data.frame(joint_test)
joint_test_df
# Create a kable table with kableExtra
joint_test_html <- joint_test_df %>%
kable(format = "html", escape = FALSE, caption = "Joint Hypothesis Test Results") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Save the output to an HTML file
file_name <- "joint_test_output.html"
save_kable(joint_test_html, file = file_name)
# Inform the user where the file has been saved
cat("The joint test results have been saved to the balance tables file in the output folder.", file_name)
# # Prepare data: create outcome variables (1 for treatment arm, 0 otherwise)
# long_data$y_treatment1 <- ifelse(long_data$group == "Treatment1", 1, 0)
# long_data$y_treatment2 <- ifelse(long_data$group == "Treatment2", 1, 0)
# long_data$y_treatment3 <- ifelse(long_data$group == "Treatment3", 1, 0)
# long_data$y_lc_control <- ifelse(long_data$group == "Local Control", 1, 0)
# long_data$y_control <- ifelse(long_data$group == "Control", 1, 0)
# view(long_data)
# # Run multinomial logistic regression (with control as baseline)
# model_f_test <- multinom(cbind(y_treatment1, y_treatment2, y_treatment3, y_lc_control, y_control) ~ value + variable, data = long_data)
#
# # View model_f_test summary
# summary(model_f_test)
# model_summary <- summary(model_f_test)
# # Perform likelihood ratio tests for the joint null hypothesis
# lr_test <- lrtest(model_f_test)
# lr_test
# summary(lr_test)
# model_summary
# # Extract coefficients and p-values
# #model_summary <- summary(model_f_test)$coefficients
# model_p_values <- model_summary$coefficients[, 4]  # p-values are typically in the 4th column of the coefficients matrix
#
# q_values <- p.adjust(model_p_values, method = "fdr")
#
# # Combine results into a tidy table
# f_test_results <- tibble(
#   variable = rownames(model_summary$coefficients),
#   coef_treatment1 = model_summary$coefficients[, 1],  # Coefficients for Treatment1
#   coef_treatment2 = model_summary$coefficients[, 2],  # Coefficients for Treatment2
#   coef_treatment3 = model_summary$coefficients[, 3],  # Coefficients for Treatment3
#   coef_control = model_summary$coefficients[, 4],     # Coefficients for Control
#   p_values = model_p_values,
#   q_values = q_values
# )
#
# # View regression results
# f_test_results
# Define the file paths
proj_paths <- list(
projects = "C:/Users/Kateri/Box/NSF Senegal",
alternative_projects = "C:/Users/km978/Box/NSF Senegal"
)
# Check if the Kateri path exists and resolve the project path accordingly
if (file.exists(proj_paths$projects)) {
proj <- kwb.utils::resolve(list(
projects = proj_paths$projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
} else {
proj <- kwb.utils::resolve(list(
projects = proj_paths$alternative_projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
}
file_path_balance_tables_df <- file.path(proj$p1, "baseline_balance_tables_data_PAP.dta")
balance_df <- read_dta(file_path_balance_tables_df)
#install.packages("writexl")
library(writexl) #to output to excel doc
library(dplyr)
library(readr) #to read in dta's
library(tidyr)
library(haven)
library(data.table)
library(tidyverse)
library(estimatr)
library(broom)
library(kableExtra) #to output to HTML tables
library(sandwich) #to wrangle data
library(lmtest)  # For likelihood ratio test
library(stats)   #for FDR q-stats
library(nnet)  #to use multilogit regression
# Define the file paths
proj_paths <- list(
projects = "C:/Users/Kateri/Box/NSF Senegal",
alternative_projects = "C:/Users/km978/Box/NSF Senegal"
)
# Check if the Kateri path exists and resolve the project path accordingly
if (file.exists(proj_paths$projects)) {
proj <- kwb.utils::resolve(list(
projects = proj_paths$projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
} else {
proj <- kwb.utils::resolve(list(
projects = proj_paths$alternative_projects,
p1 = "<projects>/Data_Management/Output/Data_Analysis/Balance_Tables"
))
}
file_path_balance_tables_df <- file.path(proj$p1, "baseline_balance_tables_data_PAP.dta")
balance_df <- read_dta(file_path_balance_tables_df)
balance_df
# Adding a single categorical variable for household training categories - this is for computing summary stats since I'm keeping the trained_hh variable
joint_df <- balance_df %>%
mutate(
group = str_sub(hhid, 3, 4),
treatment_group = case_when(
group %in% c("0A", "0B") ~ "Control",
group %in% c("1A", "1B") ~ "Treatment1",
group %in% c("2A", "2B") ~ "Treatment2",
group %in% c("3A", "3B") ~ "Treatment3",
)
) %>% select(-group)
joint_long_data <- joint_df %>%
pivot_longer(
cols = -c(hhid, hhid_village, treatment_group),  # Keep hhid and group as is, pivot all other columns
names_to = "variable",    # Create a column named "variable" for former column names
values_to = "value"       # Store values in a column named "value"
)
joint_long_data <- joint_long_data %>%
rename(group = treatment_group)
view(joint_long_data)
summary_df <- balance_df %>%
mutate(
group = str_sub(hhid, 3, 4),
treatment_group = case_when(
group %in% c("0A", "0B") ~ "Control",
group %in% c("1A", "1B") ~ "Treatment1",
group %in% c("2A", "2B") ~ "Treatment2",
group %in% c("3A", "3B") ~ "Treatment3",
group %in% c("1A", "1B", "2A", "2B", "3A", "3B") & trained_hh == 0 ~ "Local Control"
)
) %>% select(-group)
long_data_sum <- summary_df %>%
pivot_longer(
cols = -c(hhid, hhid_village, treatment_group),  # Keep hhid and group as is, pivot all other columns
names_to = "variable",    # Create a column named "variable" for former column names
values_to = "value"       # Store values in a column named "value"
)
long_data_sum <- long_data_sum %>%
rename(group = treatment_group)
# Adding a single categorical variable for household training categories - this is for running regressions to avoid multicollinearity with trained_hh
balance_df <- balance_df %>%
mutate(
# Extract the two middle characters (e.g., 2A) from hhid
group = str_sub(hhid, 3, 4),
# Assign treatment group, ensuring "Local Control" is prioritized
treatment_group = case_when(
group %in% c("0A", "0B") ~ "Control",
group %in% c("1A", "1B") ~ "Treatment1",
group %in% c("2A", "2B") ~ "Treatment2",
group %in% c("1A", "1B", "2A", "2B", "3A", "3B") & trained_hh == 0 ~ "Local Control",  # Moved to the top
group %in% c("3A", "3B") ~ "Treatment3"
)
) %>% select(-group, -trained_hh)
long_data <- balance_df %>%
pivot_longer(
cols = -c(hhid, hhid_village, treatment_group),  # Keep hhid and group as is, pivot all other columns
names_to = "variable",    # Create a column named "variable" for former column names
values_to = "value"       # Store values in a column named "value"
)
long_data <- long_data %>%
rename(group = treatment_group)
view(long_data)
long_data
run_regressions <- function(data, treatment_col, village_col, vars_to_test) {
results <- list()
for (var in vars_to_test) {
treatments <- unique(data[[treatment_col]])
treatments <- setdiff(treatments, 'Control')
for (arm in treatments) {
subset <- data %>% filter(.data[[treatment_col]] %in% c('Control', arm) & variable == var)
subset$treat <- ifelse(subset[[treatment_col]] == arm, 1, 0)
model <- lm(value ~ treat, data = subset)
clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
results <- append(results, list(data.frame(variable = var, comparison = paste('Control vs', arm),
stat = round(clustered_se[2, 1], 2),
p = round(clustered_se[2, 4], 2))))
}
for (i in 1:(length(treatments) - 1)) {
for (j in (i + 1):length(treatments)) {
subset <- data %>% filter(.data[[treatment_col]] %in% c(treatments[i], treatments[j]) & variable == var)
subset$treat <- ifelse(subset[[treatment_col]] == treatments[j], 1, 0)
model <- lm(value ~ treat, data = subset)
clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
results <- append(results, list(data.frame(variable = var, comparison = paste(treatments[i], 'vs', treatments[j]),
stat = round(clustered_se[2, 1], 2),
p = round(clustered_se[2, 4], 2))))
}
}
}
bind_rows(results)
}
names(balance_df)
vars_to_test_reg <- setdiff(names(balance_df), c("hhid", "hhid_village", "treatment_group"))
regression_results <- run_regressions(long_data, 'group', 'hhid_village', vars_to_test_reg)
#regression_results_test <- run_regressions(long_data, 'group', 'hhid_village', vars_to_test_reg)
regression_results
#<><<><><>><><<><><>>
#CREATE F-STAT FUNCTION FOR EACH VAR
#<><<><><>><><<><><>>
# Function to perform F-test for each variable
run_f_tests <- function(data, treatment_col, vars_to_test) {
results <- list()
for (var in vars_to_test) {
# Construct formula dynamically (e.g., hh_15_2 ~ group)
formula <- as.formula(paste(var, "~", treatment_col))
# Run ANOVA for each variable
anova_result <- aov(formula, data = data)
# Get the F-statistic and p-value
f_stat <- summary(anova_result)[[1]]$`F value`[1]
p_value <- summary(anova_result)[[1]]$`Pr(>F)`[1]
# Store results
results <- append(results, list(data.frame(variable = var,
f_statistic = round(f_stat, 2),
p_value = round(p_value, 2))))
}
# Combine and return the results as a data frame
return(bind_rows(results))
}
vars_to_test_fstat <- setdiff(names(balance_df), c("hhid", "hhid_village", "treatment_group"))
f_test_results <- run_f_tests(balance_df, treatment_col = "treatment_group", vars_to_test = vars_to_test_fstat)
print(f_test_results)
#library(dplyr)
library(stats)
compute_fdr_qvalues <- function(f_test_results, regression_results) {
# Combine p-values from both tests into a single dataframe
combined_results <- bind_rows(
f_test_results %>% mutate(test_type = "F-Test"),
regression_results %>% mutate(test_type = "Regression")
)
# Apply Benjamini-Hochberg correction
combined_results <- combined_results %>%
mutate(q_value = p.adjust(p_value, method = "BH"))
return(combined_results)
}
# Run the function
fdr_results <- compute_fdr_qvalues(f_test_results, regression_results)
# Print the results
print(fdr_results)
compute_fdr_qvalues <- function(regression_results) {
# Apply Benjamini-Hochberg correction to regression p-values
regression_results <- regression_results %>%
mutate(q_value = p.adjust(p, method = "BH"))  # Adjusting only regression p-values
return(regression_results)  # Return the updated regression table with q-values
}
# Run the function on regression results
regression_results_qvals <- compute_fdr_qvalues(regression_results)
# Print results
print(regression_results_qvals)
compute_fdr_qvalues <- function(regression_results) {
# Apply Benjamini-Hochberg correction to regression p-values
regression_results <- regression_results %>%
mutate(q_value = round(p.adjust(p, method = "BH"), 2))  # Adjust and round q-values # Adjusting only regression p-values
return(regression_results)  # Return the updated regression table with q-values
}
# Run the function on regression results
regression_results_qvals <- compute_fdr_qvalues(regression_results)
# Print results
print(regression_results_qvals)
regression_results
print(regression_results_qvals)
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_values))
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value))
final_table
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
# Merge F-statistics data into final_table
final_table <- final_table %>%
left_join(f_test_results, by = "variable")
final_table
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value))
final_table
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value))
final_table
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value))
final_table  %>%
rename(q = q_value)
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value)) %>%
rename(q = q_value)
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q_value)) %>%
rename(q_value = q)
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
rename(q = q_value)    %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q))
# Rearrange to stack t-stats and p-values in rows
# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
final_table <- final_table %>%
left_join(f_test_results, by = "variable")
final_table
# Replace the
final_table <- final_table %>%
mutate(across(starts_with("f_stat"), ~ ifelse(type == "p", as.character(p_value), as.character(.)))) %>%
mutate(across(everything(), ~ ifelse(grepl("p", type),
paste0("(", trimws(.x),
ifelse(as.numeric(.x) <= 0.01, "**",
ifelse(as.numeric(.x) <= 0.05, "*", "")), ")"),
.x))) %>%
mutate(
# Replace character "NaN" values with "NA" for all columns except variable and type
across(-c(variable, type), ~ ifelse(. == "(NaNNA)", "(NA)", .))  # Check for character "NaN"
)
print(final_table)
final_table <- regression_results_qvals %>%
rename(q = q_value)    %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q))
# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
# Merge F-statistics data into final_table
final_table <- final_table %>%
left_join(f_test_results, by = "variable")
final_table
final_table <- final_table %>%
# Ensure f-stat values remain unchanged except for p-values
mutate(across(starts_with("f_stat"), ~ ifelse(type == "p", as.character(p_value), as.character(.)))) %>%
# Format p-values with parentheses and add significance stars
mutate(across(everything(), ~ ifelse(
grepl("p", type),
paste0("(", trimws(.x), ifelse(as.numeric(.x) <= 0.01, "**", ifelse(as.numeric(.x) <= 0.05, "*", "")), ")"),
.x))) %>%
# Add brackets around q-values
mutate(across(everything(), ~ ifelse(
grepl("q", stat),  # If the stat column indicates q-values
paste0("[", trimws(.x), "]"),
.x))) %>%
# Replace character "NaNNA" values with "(NA)" for all columns except variable and type
mutate(across(-c(variable, type), ~ ifelse(. == "(NaNNA)", "(NA)", .)))
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
rename(q = q_value)    %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q))
# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
# Merge F-statistics data into final_table
final_table <- final_table %>%
left_join(f_test_results, by = "variable")
final_table
final_table <- final_table %>%
mutate(across(starts_with("f_stat"), ~ ifelse(type == "p", as.character(p_value), as.character(.)))) %>%
mutate(across(everything(), ~ ifelse(grepl("p", type),
paste0("(", trimws(.x),
ifelse(as.numeric(.x) <= 0.01, "**",
ifelse(as.numeric(.x) <= 0.05, "*", "")), ")"),
.x))) %>%
mutate(across(everything(), ~ as.character(ifelse(
grepl("q", stat),  # If the stat column indicates q-values
paste0("[", trimws(.x), "]"),
.x)))) %>%
mutate(
# Replace character "NaN" values with "NA" for all columns except variable and type
across(-c(variable, type), ~ ifelse(. == "(NaNNA)", "(NA)", .))  # Check for character "NaN"
)
final_table <- final_table %>%
# Ensure f-stat values remain unchanged except for p-values
mutate(across(starts_with("f_stat"), ~ ifelse(type == "p", as.character(p_value), as.character(.)))) %>%
# Format p-values with parentheses and add significance stars
mutate(across(everything(), ~ as.character(ifelse(
grepl("p", type),
paste0("(", trimws(.x), ifelse(as.numeric(.x) <= 0.01, "**", ifelse(as.numeric(.x) <= 0.05, "*", "")), ")"),
.x)))) %>%
# Add brackets around q-values
mutate(across(everything(), ~ as.character(ifelse(
grepl("q", stat),  # If the stat column indicates q-values
paste0("[", trimws(.x), "]"),
.x)))) %>%
# Replace character "NaNNA" values with "(NA)" for all columns except variable and type
mutate(across(-c(variable, type), ~ as.character(ifelse(. == "(NaNNA)", "(NA)", .)))))
# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results_qvals %>%
rename(q = q_value)    %>%
pivot_wider(names_from = comparison, values_from = c(stat, p, q))
# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
pivot_wider(names_from = comparison, values_from = value)
final_table
# Merge F-statistics data into final_table
final_table <- final_table %>%
left_join(f_test_results, by = "variable")
final_table
