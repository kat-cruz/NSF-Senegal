---
title: "Balance_table_test"
author: "Kateri Mouawad"
date: "2025-02-12"
output: html_document
---

```{r}

# Load necessary libraries
library(dplyr)
library(tidyr)
library(broom)


```



```{r}
library(dplyr)
library(tidyr)
library(broom)
library(lmtest)
library(sandwich)

# Generate synthetic data
set.seed(42)
n_households <- 500
n_villages <- 50

df <- data.frame(
  hhid = 1:n_households,
  hhid_village = sample(1:n_villages, n_households, replace = TRUE),
  treatment = factor(sample(c("control", "treatment1", "treatment2", "treatment3"), n_households, replace = TRUE))
)

for (i in 1:8) {
  df[[paste0("hh_", sprintf("%02d", i))]] <- rnorm(n_households)
}

run_regressions <- function(data, dep_vars, cluster_var, treat_var) {
  treatment_arms <- c("treatment1", "treatment2", "treatment3")
  results_list <- list()

  for (var in dep_vars) {
    control_mean <- mean(data[data[[treat_var]] == "control", var])
    row <- c(variable = var, control_mean = as.character(round(control_mean, 2)))

    for (treat in treatment_arms) {
      model <- lm(as.formula(paste(var, "~", treat_var)), data = data)
      vcov_cluster <- vcovCL(model, cluster = data[[cluster_var]])
      coeftest_res <- coeftest(model, vcov_cluster)
      t_stat <- round(coeftest_res[grepl(treat, rownames(coeftest_res)), "t value"], 2)
      p_val <- round(coeftest_res[grepl(treat, rownames(coeftest_res)), "Pr(>|t|)"], 3)
      row <- c(row, as.character(t_stat), paste0("(", p_val, ")"))
    }

    for (i in 1:(length(treatment_arms)-1)) {
      for (j in (i+1):length(treatment_arms)) {
        subset <- data[data[[treat_var]] %in% c(treatment_arms[i], treatment_arms[j]), ]
        subset[[treat_var]] <- relevel(factor(subset[[treat_var]]), ref = treatment_arms[i])
        model <- lm(as.formula(paste(var, "~", treat_var)), data = subset)
        vcov_cluster <- vcovCL(model, cluster = subset[[cluster_var]])
        coeftest_res <- coeftest(model, vcov_cluster)
        t_stat <- round(coeftest_res[2, "t value"], 2)
        p_val <- round(coeftest_res[2, "Pr(>|t|)"], 3)
        row <- c(row, as.character(t_stat), paste0("(", p_val, ")"))
      }
    }

    results_list[[var]] <- unlist(row, use.names = FALSE)  # Flatten to avoid list structure
  }

  results_df <- do.call(rbind, results_list) %>%
    as.data.frame(stringsAsFactors = FALSE)

  colnames(results_df) <- c("variable", "control_mean",
                            "treatment1_vs_control_t", "treatment1_vs_control_p",
                            "treatment2_vs_control_t", "treatment2_vs_control_p",
                            "treatment3_vs_control_t", "treatment3_vs_control_p",
                            "treatment1_vs_treatment2_t", "treatment1_vs_treatment2_p",
                            "treatment1_vs_treatment3_t", "treatment1_vs_treatment3_p",
                            "treatment2_vs_treatment3_t", "treatment2_vs_treatment3_p")

  return(results_df)
}

dep_vars <- paste0("hh_", sprintf("%02d", 1:8))
results_table <- run_regressions(df, dep_vars, cluster_var = "hhid_village", treat_var = "treatment")

print(results_table)




```

```{r}
library(dplyr)
library(gt)

# Generate synthetic data
set.seed(42)

# Create some fake data
summary_table <- data.frame(
  variable = c("trained_hh", "hh_age_h", "hh_gender_h"),
  Control = c(runif(1, 0, 1), 55, 0.5),
  Private_Treatment = c(runif(1, 0, 1), 53, 0.6),
  Public_Treatment = c(runif(1, 0, 1), 54, 0.7),
  Private_and_Public_Treatment = c(runif(1, 0, 1), 53, 0.8)
)

# Add standard deviation for each treatment
summary_table <- summary_table %>%
  mutate(
    Control_SD = c(0.1, 1.2, 0.2),
    Private_Treatment_SD = c(0.2, 1.1, 0.3),
    Public_Treatment_SD = c(0.3, 1.3, 0.4),
    Private_and_Public_Treatment_SD = c(0.4, 1.4, 0.5)
  )

# Reformat data to match your table layout
summary_table_long <- summary_table %>%
  pivot_longer(cols = starts_with("Control"), names_to = "Treatment", values_to = "Value") %>%
  pivot_longer(cols = ends_with("_SD"), names_to = "Treatment_SD", values_to = "SD")

# Format the table with SDs in parentheses
summary_table_long <- summary_table_long %>%
  mutate(Value = paste(Value, "(", SD, ")", sep = "")) %>%
  select(-SD)  # Drop SD column

# Rename columns as needed
summary_table_long <- summary_table_long %>%
  rename(Variable = variable)

# Add footnotes
footnote <- "
† Indicates that the 2's from the 'I Don't know' option for the variable value have been replaced with missing.
+ Indicates that these binaries were created from variables of Likert scale, and were selected based on the distribution of the responses.
"

# Display table with footnotes
summary_table_long %>%
  gt() %>%
  tab_footnote(
    footnote = "† Indicates that the 2's from the 'I Don't know' option for the variable value have been replaced with missing.",
    locations = cells_column_labels(columns = vars(Variable))
  ) %>%
  tab_footnote(
    footnote = "+ Indicates that these binaries were created from variables of Likert scale, and were selected based on the distribution of the responses.",
    locations = cells_column_labels(columns = vars(Variable))
  )

```

```{r}
install.packages("shiny")
library(shiny)

# Create a shiny.tag
my_tag <- tags$div(
  tags$h1("Hello World"),
  tags$p("This is a paragraph.")
)

# Print the shiny.tag object to the console
print(my_tag)
```

```{r}
library(shiny)

ui <- fluidPage(
  # Output the shiny.tag dynamically
  uiOutput("my_tag_output")
)

server <- function(input, output) {
  output$my_tag_output <- renderUI({
    # Create and return the shiny.tag
    tags$div(
      tags$h1("Hello World"),
      tags$p("This is a paragraph.")
    )
  })
}

shinyApp(ui, server)
```

```{r}
#install.packages("DT")
library(shiny)
library(DT)

# Sample summary_table (replace with your actual summary_table)
summary_table <- data.frame(
  Variable = c("trained_hh", "hh_age_h"),
  Control = c("0.00 (0.00)", "55.32 (13.13)"),
  Private_Treatment = c("0.50 (0.50)", "53.76 (12.69)"),
  Public_Treatment = c("0.52 (0.50)", "54.30 (12.90)"),
  Private_and_Public_Treatment = c("0.53 (0.50)", "53.53 (13.67)")
)

# Define UI
ui <- fluidPage(
  titlePanel("Summary Table Output"),
  DTOutput("table_output") # Placeholder for table
)

# Define Server
server <- function(input, output) {
  output$table_output <- renderDT({
    datatable(summary_table, options = list(pageLength = 5), rownames = FALSE)
  })
}

# Run the Shiny app
shinyApp(ui, server)

```

```{r}
# Set a seed for reproducibility
set.seed(42)

# Define groups and sizes
groups <- c("Control", "Treatment1", "Treatment2", "Treatment3", "Local Control")
group_sizes <- rep(100, 5)  # 100 samples per group

# Create a dataframe with hh_id, treatment groups, and some covariates
df <- data.frame(
  hhid_village = rep(paste0("010A", 1:5), each = 100),
  hhid = rep(paste0("010A02"), 500),
  group = rep(groups, each = 100),
  variable = rep(c("hh_15_2", "hh_26_", "hh_27_"), length.out = 500),
  value = rnorm(500, mean = 0, sd = 1)  # Normally distributed values for example
)

# Add some variation based on treatment groups for outcome variables
df$value[df$group == "Treatment1"] <- df$value[df$group == "Treatment1"] + 1
df$value[df$group == "Treatment2"] <- df$value[df$group == "Treatment2"] - 1
df$value[df$group == "Treatment3"] <- df$value[df$group == "Treatment3"] + 0.5

# Display the first few rows
head(df)


```
```{r}
# Function to perform F-test for each variable
run_f_tests <- function(data, treatment_col, vars_to_test) {
  results <- list()
  
  for (var in vars_to_test) {
    # Subset the data for the current variable
    subset <- data[data$variable == var, ]
    
    # Run ANOVA for each treatment group
    anova_result <- aov(value ~ get(treatment_col), data = subset)
    
    # Get the F-statistic and p-value
    f_stat <- summary(anova_result)[[1]]$`F value`[1]
    p_value <- summary(anova_result)[[1]]$`Pr(>F)`[1]
    
    # Store results
    results <- append(results, list(data.frame(variable = var, 
                                               f_statistic = round(f_stat, 2), 
                                               p_value = round(p_value, 4))))
  }
  
  # Combine and return the results as a data frame
  return(bind_rows(results))
}

# Example usage with the synthetic data
f_test_results <- run_f_tests(df, treatment_col = "group", vars_to_test = unique(df$variable))
print(f_test_results)

```
#Step 2: Function for F-tests on Each Variable
```{r}
# Function to compute Joint F-statistics for each treatment arm
run_joint_f_test <- function(data, treatment_col, vars_to_test) {
  results <- list()
  
  # Loop over each treatment arm
  treatments <- unique(data[[treatment_col]])
  treatments <- treatments[treatments != "Control"]  # Exclude 'Control'
  
  for (arm in treatments) {
    # Subset the data for the current treatment group and variables
    subset <- data[data[[treatment_col]] %in% c("Control", arm), ]
    
    # Create the regression formula
    formula <- as.formula(paste("value ~", paste(vars_to_test, collapse = " + "), "+", treatment_col))
    
    # Run the regression model
    model <- lm(formula, data = subset)
    
    # Compute F-statistic for the joint test
    f_stat <- summary(model)$fstatistic[1]
    p_value <- pf(f_stat, df1 = summary(model)$fstatistic[2], df2 = summary(model)$fstatistic[3], lower.tail = FALSE)
    
    # Store results for each treatment comparison
    results <- append(results, list(data.frame(treatment = arm, 
                                               f_statistic = round(f_stat, 2), 
                                               p_value = round(p_value, 4))))
  }
  
  # Combine and return the results as a data frame
  return(bind_rows(results))
}

# Example usage with the synthetic data
joint_f_test_results <- run_joint_f_test(df, treatment_col = "group", vars_to_test = unique(df$variable))
print(joint_f_test_results)

```



```{r}
# # Load required libraries
# library(dplyr)
# library(tidyr)
# library(lmtest)
# library(sandwich)
# 
# # Set seed for reproducibility
# set.seed(42)
# 
# # Create synthetic data
# n <- 200  # Number of households
# villages <- 20  # Number of villages
# 
# # Generate household IDs and village IDs
# hhid <- 1:n
# hhid_village <- sample(1:villages, n, replace = TRUE)
# treatment <- sample(c('control', 'treatment1', 'treatment2', 'treatment3'), n, replace = TRUE)
# 
# # Generate household-level variables
# num_vars <- 5
# 
# data <- data.frame(hhid, hhid_village, treatment)
# for (i in 1:num_vars) {
#   data[[paste0('hh_var_', sprintf('%02d', i))]] <- rnorm(n)
# }
# data
# # Function to run regressions and extract t-stats and p-values
# run_regressions <- function(data, treatment_col, village_col, vars_to_test) {
#   results <- list()
#   for (var in vars_to_test) {
#     # Control vs each treatment
#     treatments <- unique(data[[treatment_col]])
#     treatments <- setdiff(treatments, 'control')
#     for (arm in treatments) {
#       subset <- data %>% filter(!!sym(treatment_col) %in% c('control', arm))
#       subset[[treatment_col]] <- ifelse(subset[[treatment_col]] == arm, 1, 0)
#       model <- lm(as.formula(paste(var, '~', treatment_col)), data = subset)
#       clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
#       results <- append(results, list(data.frame(variable = var, comparison = paste('control vs', arm), t_stat = clustered_se[2, 3], p_value = clustered_se[2, 4])))
#     }
#     # Pairwise comparisons between treatments
#     for (i in 1:(length(treatments) - 1)) {
#       for (j in (i + 1):length(treatments)) {
#         subset <- data %>% filter(!!sym(treatment_col) %in% c(treatments[i], treatments[j]))
#         subset[[treatment_col]] <- ifelse(subset[[treatment_col]] == treatments[j], 1, 0)
#         model <- lm(as.formula(paste(var, '~', treatment_col)), data = subset)
#         clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
#         results <- append(results, list(data.frame(variable = var, comparison = paste(treatments[i], 'vs', treatments[j]), t_stat = clustered_se[2, 3], p_value = clustered_se[2, 4])))
#       }
#     }
#   }
#   bind_rows(results)
# }
# 
# # Run the regressions
# vars_to_test <- paste0('hh_var_', sprintf('%02d', 1:num_vars))
# regression_results <- run_regressions(data, 'treatment', 'hhid_village', vars_to_test)
# 
# # Pivot table to display results
# final_table <- regression_results %>%
#   pivot_wider(names_from = comparison, values_from = c(t_stat, p_value))
# 
# # View final table
# print(final_table)

```



```{r}
# Load required libraries
library(dplyr)
library(tidyr)
library(lmtest)
library(sandwich)

# Set seed for reproducibility
set.seed(42)

# Create synthetic long-format data
n <- 200  # Number of households
villages <- 20  # Number of villages

# Generate IDs and groups
hhid <- paste0(rep(1:n, each=5), sprintf('%02d', 1:5))
hhid_village <- sample(LETTERS[1:villages], n*5, replace = TRUE)
group <- sample(c('Control', 'Treatment1', 'Treatment2', 'Treatment3'), n*5, replace = TRUE)

# Generate variable names and values
variables <- rep(c('hh_age_resp', 'hh_gender', 'hh_income', 'hh_education', 'hh_assets'), times = n)
value <- rnorm(n * 5)

# Combine into a long-format dataframe
data <- data.frame(hhid_village, hhid, group, variable = variables, value)

# Function to run regressions and extract t-stats and p-values
run_regressions <- function(data, treatment_col, village_col, vars_to_test) {
  results <- list()
  for (var in vars_to_test) {
    treatments <- unique(data[[treatment_col]])
    treatments <- setdiff(treatments, 'Control')
    for (arm in treatments) {
      subset <- data %>% filter(.data[[treatment_col]] %in% c('Control', arm) & variable == var)
      subset$treat <- ifelse(subset[[treatment_col]] == arm, 1, 0)
      model <- lm(value ~ treat, data = subset)
      clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
      results <- append(results, list(data.frame(variable = var, comparison = paste('Control vs', arm), 
                                                 stat = round(clustered_se[2, 3], 2), 
                                                 p = round(clustered_se[2, 4], 2))))
    }
    for (i in 1:(length(treatments) - 1)) {
      for (j in (i + 1):length(treatments)) {
        subset <- data %>% filter(.data[[treatment_col]] %in% c(treatments[i], treatments[j]) & variable == var)
        subset$treat <- ifelse(subset[[treatment_col]] == treatments[j], 1, 0)
        model <- lm(value ~ treat, data = subset)
        clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
        results <- append(results, list(data.frame(variable = var, comparison = paste(treatments[i], 'vs', treatments[j]), 
                                                 stat = round(clustered_se[2, 3], 2), 
                                                 p = round(clustered_se[2, 4], 2))))
      }
    }
  }
  bind_rows(results)
}

# Run the regressions
vars_to_test <- unique(data$variable)
regression_results <- run_regressions(data, 'group', 'hhid_village', vars_to_test)

# Convert all columns to character before pivoting
regression_results <- regression_results %>% mutate(across(everything(), as.character))

# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results %>%
  pivot_wider(names_from = comparison, values_from = c(stat, p))

# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
  pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
  separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
  pivot_wider(names_from = comparison, values_from = value)



final_table <- final_table %>%
  mutate(across(where(is.numeric), ~ formatC(.x, format = "f", digits = 3))) %>%  # Round and format numeric columns to 2 decimal places
  mutate(across(everything(), as.character)) %>%  # Convert all columns to character for manipulation
  mutate(across(everything(), ~ ifelse(grepl("p", type),
                                       paste0("(", .x, ")"),
                                       .x)))  # Add parentheses for p.value rows

final_table <- final_table %>%
  mutate(
    variable = ifelse(type == "(p)", "", variable),
    type = ifelse(type == "(p)", "", type)
  )

# View final table
print(final_table)

```






```{r}


# Load required libraries
library(dplyr)
library(tidyr)
library(lmtest)
library(sandwich)

# Set seed for reproducibility
set.seed(42)

# Create synthetic long-format data
n <- 200  # Number of households
villages <- 20  # Number of villages

# Generate IDs and groups
hhid <- paste0(rep(1:n, each=5), sprintf('%02d', 1:5))
hhid_village <- sample(LETTERS[1:villages], n*5, replace = TRUE)
group <- sample(c('Control', 'Treatment1', 'Treatment2', 'Treatment3'), n*5, replace = TRUE)

# Generate variable names and values
variables <- rep(c('hh_age_resp', 'hh_gender', 'hh_income', 'hh_education', 'hh_assets'), times = n)
value <- rnorm(n * 5)

# Combine into a long-format dataframe
data <- data.frame(hhid_village, hhid, group, variable = variables, value)

# Function to run regressions and extract t-stats and p-values
run_regressions <- function(data, treatment_col, village_col, vars_to_test) {
  results <- list()
  for (var in vars_to_test) {
    treatments <- unique(data[[treatment_col]])
    treatments <- setdiff(treatments, 'Control')
    for (arm in treatments) {
      subset <- data %>% filter(.data[[treatment_col]] %in% c('Control', arm) & variable == var)
      subset$treat <- ifelse(subset[[treatment_col]] == arm, 1, 0)
      model <- lm(value ~ treat, data = subset)
      clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
      results <- append(results, list(data.frame(variable = var, comparison = paste('Control vs', arm), 
                                                 stat = round(clustered_se[2, 3], 2), 
                                                 p = round(clustered_se[2, 4], 2))))
    }
    for (i in 1:(length(treatments) - 1)) {
      for (j in (i + 1):length(treatments)) {
        subset <- data %>% filter(.data[[treatment_col]] %in% c(treatments[i], treatments[j]) & variable == var)
        subset$treat <- ifelse(subset[[treatment_col]] == treatments[j], 1, 0)
        model <- lm(value ~ treat, data = subset)
        clustered_se <- coeftest(model, vcov = vcovCL(model, cluster = subset[[village_col]]))
        results <- append(results, list(data.frame(variable = var, comparison = paste(treatments[i], 'vs', treatments[j]), 
                                                 stat = round(clustered_se[2, 3], 2), 
                                                 p = round(clustered_se[2, 4], 2))))
      }
    }
  }
  bind_rows(results)
}

###issue with rounding - need to first change into long format with everythingas doubles then stack pvalues, THEN change to characters to add parenthesis 


vars_to_test <- unique(data$variable)
regression_results <- run_regressions(data, 'group', 'hhid_village', vars_to_test)
regression_results
# Convert t-stat and p-value to numeric and round to two decimal places
regression_results <- regression_results %>%
  mutate(across(c(stat, p), ~ round(.x, 2))) 
#%>%  # Round t-stat and p-values
  #mutate(across(everything(), as.character))  # Convert all columns to character

# Pivot the table to have variables as rows and comparisons as columns
final_table <- regression_results %>%
  pivot_wider(names_from = comparison, values_from = c(stat, p))
final_table
# Rearrange to stack t-stats and p-values in rows
final_table <- final_table %>%
  pivot_longer(cols = -variable, names_to = 'comparison', values_to = 'value') %>%
  separate(comparison, into = c('type', 'comparison'), sep = '_', extra = 'merge') %>%
  pivot_wider(names_from = comparison, values_from = value)
final_table
# Add formatting to ensure two decimal places for all numeric values (t-stats and p-values)
final_table <- final_table %>%
  mutate(across(where(is.numeric), ~ format(.x, nsmall = 2))) %>%  # Format with 2 decimals
  mutate(across(everything(), as.character)) %>%  # Ensure all columns are characters
  mutate(across(everything(), ~ ifelse(grepl("p", type),
                                       paste0("(", trimws(.x), ")"),  # Trim any extra spaces around the value
                                       .x)))  # Add parentheses for p.value rows
# Clean up column names (variable and type) for p-values
final_table <- final_table %>%
  mutate(
    variable = ifelse(type == "(p)", "", variable),
    type = ifelse(type == "(p)", "", type)
  )

# View final table
print(final_table)
```

```{r}

# Load necessary library
library(nnet)

# Set random seed for reproducibility
set.seed(123)

# Create fake dataset for 100 households
n <- 100  # Number of households

# Generate household-level variables
hh_age_resp <- sample(18:65, n, replace = TRUE)  # Age of respondent
hh_gender <- sample(c("Male", "Female"), n, replace = TRUE)  # Gender
hh_income <- rnorm(n, mean = 30000, sd = 5000)  # Household income
hh_education <- sample(c("None", "Primary", "Secondary", "Tertiary"), n, replace = TRUE)  # Education level
hh_assets <- rnorm(n, mean = 5000, sd = 1500)  # Household assets value

# Generate treatment assignment (Control, Treatment1, or Treatment2)
group <- sample(c("Control", "Treatment1", "Treatment2"), n, replace = TRUE)

# Create a data frame
data <- data.frame(
  hh_age_resp,
  hh_gender,
  hh_income,
  hh_education,
  hh_assets,
  group
)

# Create binary treatment columns (one per treatment arm)
data$treat_control <- ifelse(data$group == 'Control', 1, 0)
data$treat_treatment1 <- ifelse(data$group == 'Treatment1', 1, 0)
data$treat_treatment2 <- ifelse(data$group == 'Treatment2', 1, 0)

# Fit the multinomial logistic regression model
model <- multinom(group ~ hh_age_resp + hh_gender + hh_income + hh_education + hh_assets, data = data)

# Print the model summary
summary(model)

# To get the predicted probabilities for each observation in the dataset
predicted_probs <- predict(model, type = "probs")

# To add the predicted probabilities to the data
data$predicted_control <- predicted_probs[, 1]
data$predicted_treatment1 <- predicted_probs[, 2]
data$predicted_treatment2 <- predicted_probs[, 3]

# View the updated data with predicted probabilities
head(data)



full_deviance <- 198.5455  # from your output

# Fit the null model
null_model <- multinom(group ~ 1, data = data)

# Null model deviance
null_deviance <- logLik(null_model)[1] * -2  # calculate deviance

# Likelihood ratio statistic
lr_statistic <- -2 * (null_deviance - full_deviance)

# Degrees of freedom
df <- length(coef(full_model))  # number of predictors

# p-value for the LR test
p_value <- 1 - pchisq(lr_statistic, df)

# Output the result
cat("LR Statistic:", lr_statistic, "\n")
cat("p-value:", p_value, "\n")





```




```{r}
# Load necessary libraries
library(nnet)  # For multinomial logit model
library(dplyr) # For data manipulation


# Set a seed for reproducibility
set.seed(123)

# Step 1: Generate a fake dataset with 200 observations
n <- 200  # Number of observations

# Generate binary outcome variables (Treatment1, Treatment2, Treatment3)
# Each household is assigned to one of the treatment arms
group <- sample(c("Treatment1", "Treatment2", "Treatment3"), n, replace = TRUE)

# Generate predictor variables (for example: age, gender, income, education)
hh_age_resp <- rnorm(n, mean = 35, sd = 10)  # Age of the respondent
hh_gender <- sample(c("Male", "Female"), n, replace = TRUE)  # Gender
hh_income <- rnorm(n, mean = 5000, sd = 1500)  # Household income
hh_education <- sample(c("Primary", "Secondary", "Tertiary"), n, replace = TRUE)  # Education level
hh_assets <- rnorm(n, mean = 2000, sd = 800)  # Household assets

# Create a data frame using the generated variables
balance_data <- data.frame(
  group = factor(group, levels = c("Treatment1", "Treatment2", "Treatment3")),  # Treatment group
  hh_age_resp,
  hh_gender,
  hh_income,
  hh_education,
  hh_assets
)

# Check the first few rows of the data
head(balance_data)

# Step 1: Define your outcome variables (binary)
outcome_vars <- c("Treatment1", "Treatment2", "Treatment3")  # Replace with your outcome variables

# Step 2: Define the predictors
predictors <- colnames(balance_data)  # All columns in balance_data will be predictors

# Step 3: Prepare an empty vector to store F-statistics
f_stats <- c()

# Step 4: Run multinomial logit for each predictor variable in balance_data
for (predictor in predictors) {
  
  # Step 4.1: Run the multinomial logit model
  formula <- as.formula(paste("group ~", predictor))  # Use the variable as the predictor
  model <- multinom(formula, data = balance_data)
  
  # Step 4.2: Extract the deviance values
  full_deviance <- logLik(model)[1] * -2  # Full model deviance
  
  # Step 4.3: Fit the null model
  null_model <- multinom(group ~ 1, data = balance_data)  # Null model (intercept only)
  null_deviance <- logLik(null_model)[1] * -2  # Null model deviance
  
  # Step 4.4: Compute the likelihood ratio statistic (F-stat equivalent)
  lr_statistic <- -2 * (null_deviance - full_deviance)
  
  # Step 4.5: Compute the degrees of freedom
  df <- length(coef(model)) - 1  # Number of predictors (subtracting 1 for the intercept)
  
  # Step 4.6: Compute the p-value for the likelihood ratio test
  p_value <- 1 - pchisq(lr_statistic, df)
  
  # Step 4.7: Store the results (F-stat and p-value) in the vector
  f_stats <- c(f_stats, list(c(p_value, lr_statistic)))
}
f_stats
# Step 5: Add the F-statistics to the final_table
# final_table <- final_table %>%
#   mutate(F_stat = unlist(f_stats)[, 2],  # Add F-statistic to final_table
#          P_value = unlist(f_stats)[, 1])  # Add p-value to final_table
# 
# # Step 6: View the final table with F-stat and p-values
# print(final_table)

```





















```{r}


# # Set seed for reproducibility
# set.seed(123)
# 
# # Generate synthetic data (already in long format)
# # Generate synthetic data (already in long format)
# n <- 200  # Number of households
# balance_test_df <- data.frame(
#   hhid = rep(1:n, each = 3),
#   group = rep(c("Control", "Treatment1", "Treatment2", "Treatment3"), n),
#   variable = rep(c("hh_08", "hh_09", "hh_10"), each = n),
#   value = c(rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3)
#   )
# )
# 
# # Function to compute summary statistics by group (means and SDs)
# compute_summary_stats <- function(df, vars) {
#   df %>%
#     filter(variable %in% vars) %>%
#     group_by(group, variable) %>%
#     summarise(mean = mean(value, na.rm = TRUE),
#               sd = sd(value, na.rm = TRUE),
#               n = n(), .groups = "drop")
# }
# 
# # Function to run t-tests for pairwise comparisons
# run_t_tests <- function(df, vars) {
#   t_test_results <- lapply(vars, function(var) {
#     # T-tests: Control vs. each treatment arm
#     control_vs_treatment <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment1"), variable == var))
#     
#     # Treatment comparisons: make sure there's only two groups
#     treatment_comparisons <- lapply(c("Treatment1", "Treatment2", "Treatment3"), function(treatment_group) {
#       # Check if both groups have data
#       treatment_data <- df %>% filter(group %in% c("Treatment1", treatment_group), variable == var)
#       
#       if (n_distinct(treatment_data$group) == 2) {
#         return(t.test(value ~ group, data = treatment_data))
#       } else {
#         return(NULL)  # Skip the comparison if there's not exactly 2 groups
#       }
#     })
#     
#     # Return t-test results
#     list(
#       control_vs_treatment = control_vs_treatment,
#       treatment_comparisons = treatment_comparisons
#     )
#   })
#   
#   return(t_test_results)
# }
# 
# # Define the list of variables to test
# vars_to_test <- c("hh_08", "hh_09", "hh_10")
# 
# # Compute summary statistics for all variables
# summary_stats <- compute_summary_stats(balance_test_df, vars_to_test)
# 
# # Run t-tests for each variable
# t_test_results <- run_t_tests(balance_test_df, vars_to_test)
# 
# # Print the summary stats
# print(summary_stats)
# 
# # Print the t-test results
# print(t_test_results)

```


```{r}
# # Load necessary libraries
# library(dplyr)
# library(tidyr)
# library(broom)
# 
# # Set seed for reproducibility
# set.seed(123)
# 
# # Generate synthetic data (already in long format)
# n <- 200  # Number of households
# balance_test_df <- data.frame(
#   hhid = rep(1:n, each = 3),
#   group = rep(c("Control", "Treatment1", "Treatment2", "Treatment3"), n),
#   variable = rep(c("hh_08", "hh_09", "hh_10"), each = n),
#   value = c(rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3)
#   )
# )
# 
# # Function to compute summary statistics by group (means and SDs)
# compute_summary_stats <- function(df, vars) {
#   df %>%
#     filter(variable %in% vars) %>%
#     group_by(group, variable) %>%
#     summarise(mean = mean(value, na.rm = TRUE),
#               sd = sd(value, na.rm = TRUE),
#               n = n(), .groups = "drop")
# }
# 
# # Function to run t-tests for pairwise comparisons
# run_t_tests <- function(df, vars) {
#   t_test_results <- lapply(vars, function(var) {
#     # T-tests: Control vs. each treatment arm
#     control_vs_treatment <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment1"), variable == var))
#     
#     # Treatment comparisons: make sure there's only two groups
#     treatment_comparisons <- lapply(c("Treatment1", "Treatment2", "Treatment3"), function(treatment_group) {
#       # Check if both groups have data
#       treatment_data <- df %>% filter(group %in% c("Treatment1", treatment_group), variable == var)
#       
#       if (n_distinct(treatment_data$group) == 2) {
#         return(t.test(value ~ group, data = treatment_data))
#       } else {
#         return(NULL)  # Skip the comparison if there's not exactly 2 groups
#       }
#     })
#     
#     # Return t-test results
#     list(
#       control_vs_treatment = control_vs_treatment,
#       treatment_comparisons = treatment_comparisons
#     )
#   })
#   
#   return(t_test_results)
# }
# 
# # Function to tidy t-test results into a table
# tidy_t_tests <- function(t_test_results, vars) {
#   results <- lapply(seq_along(t_test_results), function(i) {
#     # Extract results for each variable
#     var <- vars[i]
#     
#     # Control vs Treatment t-test results
#     control_vs_treatment <- tidy(t_test_results[[i]]$control_vs_treatment) %>%
#       mutate(variable = var, comparison = "Control vs Treatment1")
#     
#     # Pairwise treatment comparisons
#     treatment_comparisons <- bind_rows(lapply(1:3, function(j) {
#       treatment_result <- t_test_results[[i]]$treatment_comparisons[[j]]
#       
#       if (!is.null(treatment_result)) {
#         tidy(treatment_result) %>%
#           mutate(variable = var, comparison = paste("Treatment", j, "vs Treatment", j+1))
#       } else {
#         NULL
#       }
#     }))
#     
#     # Combine control vs treatment and pairwise treatment comparisons
#     bind_rows(control_vs_treatment, treatment_comparisons)
#   })
#   
#   # Combine results for all variables into one data frame
#   bind_rows(results)
# }
# 
# # Define the list of variables to test
# vars_to_test <- c("hh_08", "hh_09", "hh_10")
# 
# # Compute summary statistics for all variables
# summary_stats <- compute_summary_stats(balance_test_df, vars_to_test)
# 
# # Run t-tests for each variable
# t_test_results <- run_t_tests(balance_test_df, vars_to_test)
# 
# # Create a tidy table from the t-test results
# tidy_results <- tidy_t_tests(t_test_results, vars_to_test)
# 
# # Print the summary stats
# print(summary_stats)
# 
# # Print the tidy t-test results
# print(tidy_results)

```

```{r}
# # Set seed for reproducibility
# set.seed(123)
# 
# # Generate synthetic data
# n <- 200  # Number of households
# balance_test_df <- data.frame(
#   hhid = rep(1:n, each = 3),
#   group = rep(c("Control", "Treatment1", "Treatment2", "Treatment3"), n),
#   variable = rep(c("hh_08", "hh_09", "hh_10"), each = n),
#   value = c(rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3)
#   )
# )
# 
# # Compute summary statistics
# summary_stats <- balance_test_df %>%
#   group_by(variable, group) %>%
#   summarise(mean = mean(value, na.rm = TRUE), .groups = "drop") %>%
#   pivot_wider(names_from = group, values_from = mean)
# 
# # Function to run t-tests and store results
# run_t_tests <- function(df, vars) {
#   results <- list()
#   
#   for (var in vars) {
#     # Control vs. each treatment
#     results[[var]] <- list()
#     results[[var]][["Control vs Treatment1"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment1"), variable == var))
#     results[[var]][["Control vs Treatment2"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment2"), variable == var))
#     results[[var]][["Control vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment3"), variable == var))
#     
#     # Treatment pairwise comparisons
#     results[[var]][["Treatment1 vs Treatment2"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment1", "Treatment2"), variable == var))
#     results[[var]][["Treatment1 vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment1", "Treatment3"), variable == var))
#     results[[var]][["Treatment2 vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment2", "Treatment3"), variable == var))
#   }
#   
#   return(results)
# }
# 
# # Define the list of variables to test
# vars_to_test <- c("hh_08", "hh_09", "hh_10")
# 
# # Run t-tests
# t_test_results <- run_t_tests(balance_test_df, vars_to_test)
# 
# # Convert t-test results into a tidy format
# tidy_results <- lapply(names(t_test_results), function(var) {
#   bind_rows(lapply(names(t_test_results[[var]]), function(comp) {
#     tidy(t_test_results[[var]][[comp]]) %>%
#       mutate(variable = var, comparison = comp)
#   }))
# }) %>%
#   bind_rows() %>%
#   select(variable, comparison, estimate, p.value) %>%
#   pivot_wider(names_from = comparison, values_from = c(estimate, p.value))
# 
# # Combine summary statistics with test results into the desired format
# final_table <- summary_stats %>%
#   left_join(tidy_results, by = "variable") %>%
#   arrange(variable)
# 
# # Print final table
# print(final_table, n = Inf)
```

```{r}
# Generate synthetic data with village variable

######################################################## first past at test using sythetic data #######################################
# set.seed(123)
# n <- 200  # Number of households
# balance_test_df <- data.frame(
#   hhid = rep(1:n, each = 3),
#   village = rep(1:50, length.out = n * 3),  # Add village variable
#   group = rep(c("Control", "Treatment1", "Treatment2", "Treatment3"), n),
#   variable = rep(c("hh_08", "hh_09", "hh_10"), each = n),
#   value = c(rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3),
#             rnorm(n, mean = 0.5, sd = 0.1),
#             rnorm(n, mean = 1.5, sd = 0.2),
#             rnorm(n, mean = 2.5, sd = 0.3)
#   )
# )
# balance_test_df

# Print final table
#print(final_table, n = Inf)
```


```{r}

# Load necessary libraries
# library(dplyr)
# library(tidyr)
# library(broom)


########################################################### first pass at tests - good intital table output #####################
# Set seed for reproducibility
set.seed(123)

# Generate synthetic data
n <- 200  # Number of households
balance_test_df <- data.frame(
  hhid = rep(1:n, each = 3),
  group = rep(c("Control", "Treatment1", "Treatment2", "Treatment3"), n),
  variable = rep(c("hh_08", "hh_09", "hh_10"), each = n),
  value = c(rnorm(n, mean = 0.5, sd = 0.1),
            rnorm(n, mean = 1.5, sd = 0.2),
            rnorm(n, mean = 2.5, sd = 0.3),
            rnorm(n, mean = 0.5, sd = 0.1),
            rnorm(n, mean = 1.5, sd = 0.2),
            rnorm(n, mean = 2.5, sd = 0.3),
            rnorm(n, mean = 0.5, sd = 0.1),
            rnorm(n, mean = 1.5, sd = 0.2),
            rnorm(n, mean = 2.5, sd = 0.3),
            rnorm(n, mean = 0.5, sd = 0.1),
            rnorm(n, mean = 1.5, sd = 0.2),
            rnorm(n, mean = 2.5, sd = 0.3)
  )
)
balance_test_df
summary_stats <- balance_test_df %>%
  group_by(variable, group) %>%
  summarise(mean = mean(value, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = group, values_from = mean) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))

# Function to run t-tests and store results
run_t_tests <- function(df, vars) {
  results <- list()
  
  for (var in vars) {
    # Control vs. each treatment
    results[[var]] <- list()
    results[[var]][["Control vs Treatment1"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment1"), variable == var))
    results[[var]][["Control vs Treatment2"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment2"), variable == var))
    results[[var]][["Control vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Control", "Treatment3"), variable == var))
    
    # Treatment pairwise comparisons
    results[[var]][["Treatment1 vs Treatment2"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment1", "Treatment2"), variable == var))
    results[[var]][["Treatment1 vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment1", "Treatment3"), variable == var))
    results[[var]][["Treatment2 vs Treatment3"]] <- t.test(value ~ group, data = df %>% filter(group %in% c("Treatment2", "Treatment3"), variable == var))
  }
  
  return(results)
}

balance_test_df
# Define the list of variables to test
vars_to_test <- c("hh_08", "hh_09", "hh_10")

# Run t-tests
t_test_results <- run_t_tests(balance_test_df, vars_to_test)
t_test_results
# Convert t-test results into a tidy format
# tidy_results <- lapply(names(t_test_results), function(var) {
#   bind_rows(lapply(names(t_test_results[[var]]), function(comp) {
#     tidy(t_test_results[[var]][[comp]]) %>%
#       mutate(variable = var, comparison = comp)
#   }))
# }) %>%
#   bind_rows() %>%
#   select(variable, comparison, estimate, p.value) %>%
#   pivot_wider(names_from = comparison, values_from = c(estimate, p.value))
# tidy_results

tidy_results <- lapply(names(t_test_results), function(var) {
  bind_rows(lapply(names(t_test_results[[var]]), function(comp) {
    tidy(t_test_results[[var]][[comp]]) %>%
      mutate(variable = var, comparison = comp)
  }))
}) %>%
  bind_rows() %>%
  select(variable, comparison, estimate, p.value) %>%
  mutate(across(c(estimate, p.value), ~ round(.x, 2))) %>%
  pivot_wider(names_from = comparison, values_from = c(estimate, p.value))

# # Reshape the data for the final table: combine estimates and p-values
final_table <- summary_stats %>%
  left_join(tidy_results, by = "variable") %>%
  arrange(variable) %>%
  select(variable, Control, contains("estimate"), contains("p.value")) %>%
  pivot_longer(cols = starts_with("estimate_") | starts_with("p.value_"),
               names_to = c("comparison", "stat"), names_pattern = "(.*)_(.*)", values_to = "value") %>%
  pivot_wider(names_from = stat, values_from = value) %>%  # Separate estimates and p-values
  mutate(across(contains("estimate"), ~ paste0(.x, " (",
                                               round(get(gsub("estimate", "p.value", cur_column())), 3), ")"),
                .names = "{.col}_formatted")) %>%
  select(-contains("p.value"), -contains("estimate"))

# Add parentheses around all values in rows where comparison = "p.value"
final_table <- final_table %>%
  mutate(across(where(is.numeric), ~ formatC(.x, format = "f", digits = 2))) %>%  # Round and format numeric columns to 2 decimal places
  mutate(across(everything(), as.character)) %>%  # Convert all columns to character for manipulation
  mutate(across(everything(), ~ ifelse(grepl("p.value", comparison), 
                                       paste0("(", .x, ")"), 
                                       .x)))  # Add parentheses for p.value rows
final_table <- final_table %>%
  mutate(
    variable = ifelse(comparison == "(p.value)", "", variable),
    comparison = ifelse(comparison == "(p.value)", "", comparison)
  ) %>%
select(-"comparison", -"Control")


 final_table
# Print final table
#print(final_table, n = Inf)

```

# Run trinomial regression 

```{r}
# 
# # Load necessary libraries
# library(nnet)
# library(dplyr)
# library(tidyr)
# library(broom)
# 
# set.seed(123)
# 
# # Generate synthetic data in wide format
# n <- 200  # Number of households
# 
# # Create the dataframe in wide format
# balance_test_wide <- data.frame(
#   hhid = 1:n,
#   group = sample(c("Control", "Treatment1", "Treatment2", "Treatment3"), n, replace = TRUE),
#   hh_08 = rnorm(n, mean = 0.5, sd = 0.1),
#   hh_09 = rnorm(n, mean = 1.5, sd = 0.2),
#   hh_10 = rnorm(n, mean = 2.5, sd = 0.3)
# )
# 
# 
# 
# # Convert the data from long to wide format
# 
# # Convert group into a factor variable with Control as the reference category
# balance_test_wide <- balance_test_wide %>%
#   mutate(group = factor(group, levels = c("Control", "Treatment1", "Treatment2", "Treatment3")))
# balance_test_wide
# # Run multinomial logistic regression (Control is the reference category)
# multinom_model <- multinom(group ~ hh_08 + hh_09 + hh_10, data = balance_test_wide)
# 
# # Summarize results
# summary(multinom_model)
# 
# # Convert results into a tidy format
# tidy_results <- tidy(multinom_model, conf.int = TRUE, exponentiate = TRUE)
# 
# # Print coefficients with p-values
# tidy_results
# 
# 
# long_results <- tidy_results %>%
#   pivot_wider(names_from = term, values_from = estimate) %>%
#   pivot_longer(cols = -c(y.level), names_to = "variable", values_to = "estimate") %>%
#   rename(Treatment = y.level) %>%
#   arrange(variable, Treatment)
# 
# # Print output
# print(long_results)


```


```{r}
#install.packages("nnet")
# 
# library(nnet)
# library(broom)
# library(tidyverse)
# 
# # Generate the wide-format data frame
# set.seed(123)
# n <- 200
# wide_df <- data.frame(
#   hhid = 1:n,
#   Treatment1 = sample(0:1, n, replace = TRUE),
#   Treatment2 = sample(0:1, n, replace = TRUE),
#   Treatment3 = sample(0:1, n, replace = TRUE),
#   hh_08 = rnorm(n, mean = 0.5, sd = 0.1),
#   hh_09 = rnorm(n, mean = 1.5, sd = 0.2),
#   hh_10 = rnorm(n, mean = 2.5, sd = 0.3)
# )
# 
# # Create a "long" dependent variable for multinomial logistic regression
# wide_df$Treatment <- factor(1*(wide_df$Treatment1 == 1) + 
#                               2*(wide_df$Treatment2 == 1) + 
#                               3*(wide_df$Treatment3 == 1), 
#                             levels = c(1, 2, 3), labels = c("Treatment1", "Treatment2", "Treatment3"))
# 
# # Fit the multinomial logistic regression model
# model <- multinom(Treatment ~ hh_08 + hh_09 + hh_10, data = wide_df)
# 
# # Tidy the model results
# tidy_results <- tidy(model)
# tidy_results
# # Reshape the tidy results into wide format
# final_results <- tidy_results %>%
#   filter(str_detect(term, "^hh")) %>%  # Ensure we only keep terms related to hh_08, hh_09, hh_10
#   pivot_wider(names_from = term, values_from = estimate) %>%
#   select(variable = term, `(Intercept)`, Treatment1, Treatment2, Treatment3)
# 
# # View the final results
# print(final_results)


```















##Now to include survey questions and values 

```{r}

# Define variables and comparison groups
variables <- paste0("health_5_3_", 1:8, "_")
comparisons <- c("Control vs Treatment1", "Control vs Treatment2", "Control vs Treatment3",
                 "Treatment1 vs Treatment2", "Treatment1 vs Treatment3", "Treatment2 vs Treatment3")

# Generate synthetic values for comparisons
set.seed(123)  # For reproducibility
data_values <- matrix(round(runif(8 * 6, -0.25, 0.25), 2), nrow = 8, dimnames = list(variables, comparisons))

# Generate synthetic p-values
p_values <- matrix(round(runif(8 * 6, 0, 1), 2), nrow = 8, dimnames = list(variables, comparisons))

# Convert to data frame
synthetic_data <- as.data.frame(data_values) %>%
  rownames_to_column(var = "variable") %>%
  bind_rows(as.data.frame(p_values) %>% rownames_to_column(var = "variable") %>% mutate(variable = paste0("(", variable, ")")))

# Print result
print(synthetic_data, row.names = FALSE)

```


```{r}
# library(tibble)
# 
# 
# # Define the data with indentation
# health_5_3_df <- tribble(
#   ~health_5_3,
#   "What illness did you contract this past month?",
#   "    Cold",
#   "    Flu",
#   "    Malaria",
#   "    Diarrhea",
#   "    COVID-19",
#   "    Typhoid",
#   "    Dengue",
#   "    Pneumonia"
# )
# 
# # Print the structured data
# print(health_5_3_df, row.names = FALSE)
# 


```

```{r}
# library(glue)
# # Create the data
# illnesses <- c("Cold", "Flu", "Malaria", "Diarrhea", "COVID-19", "Typhoid", "Dengue", "Pneumonia")
# 
# # Format with indentation
# health_5_3_df <- tibble(
#   health_5_3 = c("What illness did you contract this past month?", glue("    {illnesses}"))
# )
# 
# print(health_5_3_df, row.names = FALSE)

```
```{r}

library(tibble)

# Define the data with Unicode indentation
health_5_3_df <- tribble(
  ~health_5_3,
  "What illness did you contract this past month?",
  "\u00A0\u00A0\u00A0Cold",
  "\u00A0\u00A0\u00A0Flu",
  "\u00A0\u00A0\u00A0Malaria",
  "\u00A0\u00A0\u00A0Diarrhea",
  "\u00A0\u00A0\u00A0COVID-19",
  "\u00A0\u00A0\u00A0Typhoid",
  "\u00A0\u00A0\u00A0Dengue",
  "\u00A0\u00A0\u00A0Pneumonia"
)

print(health_5_3_df, row.names = FALSE)


# Define the data with Unicode indentation
health_5_3_df <- tribble(
  ~health_5_3,
  "What illness did you contract this past month?",
  "                Cold",
  "                Flu",
  "                Malaria",
  "                Diarrhea",
  "                COVID-19",
                   "Typhoid",
  "                 Dengue",
  "                Pneumonia"
)

print(health_5_3_df, row.names = FALSE)

```

```{r}
# library(tibble)
# library(stringr)
# 
# # Create the illnesses list
# illnesses <- c("Cold", "Flu", "Malaria", "Diarrhea", "COVID-19", "Typhoid", "Dengue", "Pneumonia")
# 
# # Format with indentation using string padding
# health_5_3_df <- tibble(
#   health_5_3 = c("What illness did you contract this past month?", str_pad(illnesses, width = 15, side = "left"))
# )
# 
# print(health_5_3_df, row.names = FALSE)

```

```{r}
# cat("What illness did you contract this past month?\n",
#     "   Cold\n",
#     "   Flu\n",
#     "   Malaria\n",
#     "   Diarrhea\n",
#     "   COVID-19\n",
#     "   Typhoid\n",
#     "   Dengue\n",
#     "   Pneumonia\n")

```

